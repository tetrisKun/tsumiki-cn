---
description: 自动调试过程，用于解决测试错误。从确认所有测试用例、调查错误原因到修复，逐步执行，目标是提高测试用例的成功率。
---
解决测试错误。
#ultrathink

# step
1. 首先执行任务确认所有测试用例，并将测试用例的错误设置到待办事项中
2. 对每个对象执行以下操作
　 - 用任务详细调查测试的错误原因
 　- 使用 Task 工具直接执行 <green_task>，参数传递错误的原因进行修复
3. 目标是提高测试用例的成功数
4. 测试错误解决后，使用 Task 工具直接执行 <refactor_task> 进行重构
5. 最后确认整体测试的成功率并生成报告

# rule
NEVER: 跳过测试
NEVER: 删除现有测试用例

# info

<green_task>
# 错误解决（实现）

执行错误解决。

## 事前准备

执行开发上下文的准备：

1. **读取附加规则**
   - 如果存在 `AGENTS.md` 文件则读取
   - 如果存在 `docs/rule` 目录则读取
   - 如果存在 `docs/rule/tdd` 目录则读取
   - 如果存在 `docs/rule/tdd/green` 目录则读取
   - 读取各目录内的所有文件，作为附加规则应用

2. **使用 @agent-symbol-searcher 搜索实现相关信息，并读取找到的文件**
   - 搜索现有的类似功能或工具函数，使用Read工具读取相应文件
   - 识别实现模式或架构指南，使用Read工具读取设计文档
   - 确认依赖关系和导入路径，使用Read工具读取相关文件


读取完成后，基于准备好的上下文信息开始Green task（实现）的工作。

**测试执行时使用Task工具**

## 可靠性级别指示

实现代码创建时，对于各实现内容应该按照以下信号注释与原始资料的核对状况：

- 🔵 **蓝信号**: 参考原始资料，基本上没有推测的情况
- 🟡 **黄信号**: 从原始资料进行合理推测的情况
- 🔴 **红信号**: 原始资料中没有的推测情况

## 目标

- 执行 $ARGUMENTS 的错误 **实现** 修复

## 实现原则

- **测试一定要通过是最优先的**
- 代码的美观性是其次（在Refactor中改进）
- "暂且能用"的水平就可以
- 复杂的逻辑留到后期，尽量采用简单实现
- 测试迟迟无法通过时，使用Task工具调查失败原因后，再制定修正计划进行实现
- 如果现有测试出现错误，根据规格进行适当修正
- **模拟使用的限制**: 不在测试代码之外编写模拟（实现代码应该编写实际的逻辑）
- **文件大小管理**: 当实现文件超过800行时考虑进行文件分割
- NEVER: 禁止跳过必要的测试
- NEVER: 禁止删除必要的测试
- NEVER: 禁止在实现代码中编写模拟・存根
- NEVER: 禁止在实现代码中使用内存存储代替数据库
- NEVER: 禁止在实现代码中省略数据库操作

## 实现时的中文注释要求

实现代码必须包含以下中文注释：

### 函数・方法级别的注释

```javascript
/**
 * 【功能概述】: [这个函数做什么的中文说明]
 * 【实现方针】: [为什么选择这样的实现方法的说明]
 * 【测试对应】: [明确说明这是为了通过哪些测试用例的实现]
 * 🔵🟡🔴 可靠性级别: [这个实现基于原始资料的程度]
 * @param {type} paramName - [参数的说明]
 * @returns {type} - [返回值的说明]
 */
function {{function_name}}(paramName) {
  // 【实现内容】: [实现处理的详细说明]
}
```

### 处理块级别的注释

```javascript
function processData(input) {
  // 【输入值验证】: [检查输入值有效性的理由和方法] 🔵🟡🔴
  if (!input) {
    throw new Error('输入值不正确'); // 【错误处理】: [为什么需要这个错误的说明] 🔵🟡🔴
  }

  // 【数据处理开始】: [说明主要处理的开始] 🔵🟡🔴
  // 【处理方针】: [这个处理如何对通过测试有贡献的说明] 🔵🟡🔴
  const result = {
    // 【结果结构】: [说明返回值的结构和原因]
    validData: [],
    invalidData: [],
    errors: [],
  };

  // 【结果返回】: [说明返回处理结果的理由和内容]
  return result;
}
```

### 变量・常量的注释

```javascript
// 【常量定义】: [这个常量为什么需要以及使用目的]
const MAX_FILE_SIZE = 1024 * 1024; // 【限制值】: 设置文件大小的上限（1MB）

// 【变量初始化】: [为什么这个变量对通过测试是必要的说明]
let processedCount = 0; // 【计数器】: 追跟处理完毕文件数的计数器
```

### 错误处理的注释

```javascript
try {
  // 【实际处理执行】: [说明执行实际处理的部分]
  const data = processFile(filePath);
} catch (error) {
  // 【错误捕捉】: [当发生错误时的处理方针]
  // 【测试要求对应】: [为了满足测试期望的错误处理的处理]
  return {
    success: false,
    error: error.message, // 【错误信息】: 适当地返回测试验证的错误消息
  };
}
```

## 实现示例

```javascript
/**
 * 【功能概述】: 验证JSON文件路径，分类有效/无效的路径
 * 【实现方针】: 仅实现通过测试用例所需的最少功能
 * 【测试对应】: 为了通过tdd-red阶段创建的测试用例的实现
 */
function {{function_name}}(input) {
  // 【输入值验证】: 早期检测不正确的输入值以防止错误
  if (!input) {
    // 【错误处理】: 对应测试期望的错误情况
    throw new Error('需要输入值');
  }

  // 【最小限实现】: 通过测试的最简单实现
  // 【允许硬编码】: 计划在Refactor阶段改进，目前阶段可以使用固定值
  return {{simple_return_value}};
}
```

## 分步实现指南

1. **首先只通过一个测试用例**
   - 【实现策略】: 避免同时处理多个测试，以免造成复杂化
   - 【品质保证】: 逐个确实实现以确保品质
2. **采用最简单的方法实现**
   - 【简单实现】: 复杂的算法留到后续Refactor中添加
   - 【可读性优先】: 目前阶段最优先提高易理解性
3. **意识到文件大小的实现**
   - 【800行限制】: 当实现文件超过800行时考虑分割
   - 【模块设计】: 按功能单位适当分离文件
   - 【函数分割】: 将较长的函数分割成小单位实现
   - 【责任边界】: 明确每个文件的责任范围并实现
   - 【分割策略】: 按功能・层・域将文件分离
4. **考虑代码品质标准**
   - 【静态分析对应】: 力求lint和typecheck没有错误的实现
   - 【格式统一】: 与项目现有格式保持一致的实现
   - 【命名规则遵守】: 遵守项目命名规则的实现
5. **其他测试用例留到后期**
   - 【分步开发】: 按照TDD原则逐步进行
   - 【影响范围限制】: 将变更影响最小化
6. **错误处理也是最小限**
   - 【必要最小限】: 仅实现测试要求的部分
   - 【将来可扩展】: 计划在Refactor阶段添加详细的错误处理
7. **模拟使用的限制**
   - 【实现代码限制】: 实现代码中不使用模拟・存根
   - 【测试代码限定】: 模拟仅在测试代码中使用
   - 【实际逻辑实现】: 实现代码应该编写实际的处理
   - 【依赖关系注入】: 根据需要采用依赖性注入模式实现

## 请提供

1. **实现代码**: 通过测试的代码（包含必需的中文注释）
2. **测试执行结果**: 使用Task工具确认实际测试通过
3. **实现说明**: 如何考虑实现的（与中文注释的对应关系）
4. **问题的确定**: 当前实现的问题点（重构目标的明确化）
5. **文件大小检查**: 实现文件的行数确认（800行超过时的分割计划）
6. **模拟使用确认**: 确认实现代码中不包含模拟・存根

实现完成后，执行以下操作：

1. **手动确认**: 如果不满足自动转换条件，请提供以下内容：
   - "我使用Task工具确认测试已通过。"
   - "当前实现: [简洁说明]"
   - "实现中包含的中文注释: [注释的目的和内容]"
   - "重构候选: [应该改进的点]"
   - "是否可以进行到下一个Refactor阶段？"

## 品质判定标准

```
✅ 高品质:
- 测试结果: 使用Task工具执行全部成功
- 实现品质: 简单且能工作
- 重构部分: 能够明确指定
- 功能问题: 无
- 编译错误: 无
- 文件大小: 800行以下或分割计划明确
- 模拟使用: 实现代码不包含模拟・存根

⚠️ 需要改进:
- 部分测试失败（用Task工具检测）
- 实现过于复杂
- 重构方针不明确
- 功能有顾虑
- 存在编译错误
- 文件大小超过800行且分割计划不明确
- 实现代码包含模拟・存根
```

</green_task>

<refactor_task>
---
description: 执行TDD的Refactor阶段。在通过测试的实现完成后，进行代码质量改进和重构。
---

# TDD Refactor阶段（代码改进）

执行TDD的Refactor阶段。

## 事前准备

执行开发上下文的准备：

1. **读取附加规则**
   - 如果存在 `AGENTS.md` 文件则读取
   - 如果存在 `docs/rule` 目录则读取
   - 如果存在 `docs/rule/tdd` 目录则读取
   - 如果存在 `docs/rule/tdd/refactor` 目录则读取
   - 读取各目录内的所有文件，作为附加规则应用

2. **使用 @agent-symbol-searcher 搜索重构相关信息，并读取找到的文件**
   - 搜索现有的代码风格和最佳实践，使用Read工具读取风格指南
   - 识别项目整体的架构模式，使用Read工具读取设计文档
   - 确认可重用的工具函数或组件，使用Read工具读取相关文件

3. **直接读取相关的外部文件**
   - 根据需要读取相关的设计文档或任务文件

读取完成后，基于准备好的上下文信息开始Refactor阶段（代码改进）的工作。

## 可靠性级别指示

重构时，对于各改进内容应该按照以下信号注释与原始资料的核对状况：

- 🔵 **蓝信号**: 参考原始资料，基本上没有推测的情况
- 🟡 **黄信号**: 从原始资料进行合理推测的情况
- 🔴 **红信号**: 原始资料中没有的推测情况

## 目标

改进Green阶段实现的代码。**测试一定要继续通过**是前提条件。

## 改进的观点

### 1. 提高可读性

- 改进变量名・函数名
- 充实中文注释
- 让代码的结构更容易理解

### 2. 消除重复代码（DRY原则）

- 共通化类似处理
- 提取常量
- 创建辅助函数

### 3. 改进设计

- 应用单一责任原则
- 整理依赖关系
- 考虑模块化

- NEVER: 禁止在实现代码中编写模拟・存根
- NEVER: 禁止在实现代码中使用内存存储代替数据库

### 4. 文件大小的优化

- 将文件大小优化为500行以下的分割・最优化
- 按功能分割较长的文件
- 设置适当的模块边界

### 5. 确保代码品质

- 解消lint错误
- 解消typecheck错误
- 统一格式
- 静态分析工具检查清除

### 6. 安全审查

- 检测和修复导致漏洞的实现
- 强化输入值验证
- 确认SQL注入对策
- 确认XSS（Cross-Site Scripting）对策
- 确认CSRF（Cross-Site Request Forgery）对策
- 避免数据泄漏风险
- 认证・认可的恰当实现

### 7. 性能审查

- 算法的计算量分析
- 内存使用量的最优化
- 删除不必要的处理
- 考虑缓存策略
- 数据库查询的最优化
- 循环处理的效率化
- 异步处理的恰当实现

### 8. 充实错误处理

- 输入值的验证
- 恰当的错误消息
- 异常处理的改进

## 重构时的中文注释强化要求

重构时应该改进现有的中文注释，并添加新注释：

### 改进后的函数・方法的注释

```javascript
/**
 * 【功能概述】: [重构后功能的详细说明]
 * 【改进内容】: [进行了什么改进的说明]
 * 【设计方针】: [为什么采用这个设计的理由]
 * 【性能】: [性能方面的考虑事项]
 * 【可维护性】: [为了便于维护的工夫]
 * 🔵🟡🔴 可靠性级别: [这个改进基于原始资料的程度]
 * @param {type} paramName - [参数的详细说明和制约]
 * @returns {type} - [返回值的详细说明和保证事项]
 */
function improvedFunction(paramName) {
  // 【实现详细】: [改进后实现的内容和理由]
}
```

### 辅助函数・工具的注释

```javascript
/**
 * 【辅助函数】: [这个函数的角色和创建理由]
 * 【可重用性】: [在什么场景下可以重用]
 * 【单一责任】: [这个函数担当的责任范围]
 */
function helperFunction(input) {
  // 【处理效率化】: [效率化处理的工夫] 🔵🟡🔴
  // 【可读性提高】: [提高代码易读性的机制] 🔵🟡🔴
}
```

### 常量・设置值的注释

```javascript
// 【设置常量】: [这个常量的角色和设置理由] 🔵🟡🔴
// 【可调整性】: [将来需要调整的可能性和方法] 🔵🟡🔴
const IMPROVED_CONSTANT = 100; // 【已优化】: 基于性能测试的优化 🔵🟡🔴

// 【设置对象】: [整合设置的理由和管理方针]
const CONFIG = {
  // 【各设置项目】: [各设置值的意义和影响范围]
  maxRetries: 3, // 【重试次数】: 基于实际运营经验的恰当次数
  timeout: 5000, // 【超时】: 考虑用户体验的时间设置
};
```

### 错误处理改进的注释

```javascript
try {
  // 【安全处理执行】: [异常发生的可能性和对策]
  const result = riskyOperation();
} catch (error) {
  // 【详细错误处理】: [根据错误种类进行恰当处理]
  // 【用户体验】: [对于用户易于理解的错误对应]
  if (error.code === 'SPECIFIC_ERROR') {
    // 【特定错误对应】: [这个错误特化处理的理由]
    return handleSpecificError(error);
  }
  // 【一般错误对应】: [对于非预期错误的安全处理]
  return handleGenericError(error);
}
```

## 重构的步骤

1. **确认当前所有测试通过**
   - 【品质保证】: 重构前的动作确认
   - 【安全性确保】: 防止因变更导致功能破损
   - 【执行方法】: 使用Task工具执行测试，详细分析结果
2. **代码・测试排除检查**
   - 【.gitignore确认】: 检查本应确认的代码文件是否被排除
   - 【测试排除确认】: 检查测试是否被 `describe.skip`、`it.skip`、`test.skip` 等禁用
   - 【jest设置确认】: 检查 `jest.config.js` 或 `package.json` 的 `testPathIgnorePatterns` 等是否排除了测试文件
   - 【执行对象确认】: 检查应该执行的测试和代码是否适当包含在对象中
3. **开发时生成文件的清理**
   - 【不必要文件检测】: 检测・删除开发中创建的临时文件
   - 【对象文件模式】: 确认符合以下模式的文件
     - `debug-*.js`、`debug-*.ts`: 调试用脚本
     - `test-*.js`、`test-*.ts`、`temp-*.js`: 临时测试文件
     - `*.tmp`、`*.temp`、`*.bak`、`*.orig`: 临时・备份文件
     - `*~`、`.DS_Store`: 编辑器・系统生成文件
     - `test-output-*`、`*.test-output`: 测试输出文件
   - 【安全确认】: 删除前确认各文件的内容，检查是否包含重要代码
   - 【选择性删除】: 仅删除判断为不必要的文件，保持必要的文件
   - 【删除日志】: 将删除的文件和删除理由记录为日志
   - 【执行步骤】:
     1. 用 `find . -name "debug-*" -o -name "test-*" -o -name "temp-*" -o -name "*.tmp" -o -name "*.temp" -o -name "*.bak" -o -name "*.orig" -o -name "*~" -o -name ".DS_Store" | grep -v node_modules` 检测文件
     2. 用Read工具确认各文件的内容
     3. 删除判断为不必要的文件，记录删除理由
4. **执行安全审查**
   - 【脆弱性检查】: 识别代码整体的安全问题
   - 【输入检证确认】: 确认对不正确输入值的防御机能
   - 【安全指南应用】: 应用业界标准的安全最佳实践
5. **执行性能审查**
   - 【计算量分析】: 评估算法的时间计算量・空间计算量
   - 【瓶颈特定】: 特定处理速度或内存使用的问题部分
   - 【最优化策略】: 制定具体的性能改进施策
6. **逐个应用小改进**
   - 【分步改进】: 限制影响范围的安全变更
   - 【可追踪性】: 确保变更内容的可追踪性
7. **各改进后执行测试**
   - 【持续验证】: 每次改进后确认动作
   - 【早期发现】: 问题的早期发现和修正
   - 【执行方法】: 使用Task工具执行测试，确认改进的影响
8. **如果测试失败则立即回滚**
   - 【迅速复旧】: 问题发生时的快速对应
   - 【稳定性维持】: 保持系统的稳定状态

## 注意事项

- **不进行功能的变更**（禁止添加新功能）
- **如果测试无法通过则立即修正**
- **不进行一次性的大规模变更**
- **也要提高中文注释的品质**
- **为了品质确认的测试执行时使用Task工具**


## 请提供

1. **安全审查结果**: 漏洞的有无和对应策略
2. **性能审查结果**: 性能课题的分析和改进策略
3. **改进后的代码**: 重构后的代码（包含强化的中文注释）
4. **改进要点的说明**: 改进了什么以及如何改进（包括安全・性能观点）
5. **测试执行结果**: 使用Task工具确认所有测试继续通过
6. **品质评价**: 当前代码的品质级别（包括安全・性能评价）
7. **注释改进内容**: 如何强化了中文注释

## 重构示例

```javascript
// Before: 硬编码
function add(a, b) {
  return 5; // 暂且能用的实现
}

// After: 恰当的实现（包含改进的中文注释）
/**
 * 【功能概述】: 加算两个数值，返回结果
 * 【改进内容】: 删除硬编码，实现实际的加算处理
 * 【设计方针】: 重视输入值验证和类型安全性的设计
 * 【错误处理】: 对不正确的输入实现恰当的异常处理
 */
function add(firstNumber, secondNumber) {
  // 【输入值验证】: 早期检测非数值的输入以防止错误
  // 【类型安全性】: 配合TypeScript的类型检查进行运行时验证
  if (typeof firstNumber !== 'number' || typeof secondNumber !== 'number') {
    // 【用户体验】: 为开发者提供易于理解的错误消息
    throw new Error('参数必须是数值');
  }

  // 【主要处理】: 简单且确实的加算处理
  // 【性能】: 避免不必要的处理的高效实现
  return firstNumber + secondNumber;
}
```

重构完成后，执行以下操作：

1. **品质判定**: 以下列标准判定重构成果的品质
   - 测试结果: 所有测试继续成功
   - 安全性: 未发现重大漏洞
   - 性能: 未发现重大性能课题
   - 重构品质: 目标达成
   - 代码品质: 向适当的级别提高

## 品质判定标准

```
✅ 高品质:
- 测试结果: 使用Task工具执行全部继续成功
- 安全性: 无重大漏洞
- 性能: 无重大性能课题
- 重构品质: 目标达成
- 代码品质: 适当的级别
- 文档: 完成

⚠️ 需要改进:
- 部分测试失败（用Task工具检测）
- 发现安全漏洞
- 发现性能课题
- 重构目标未达成
- 品质改进不足
- 文档不备
```

</refactor_task>
