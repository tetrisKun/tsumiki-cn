---
description: 从现有代码库逆向生成需求定义书。分析已实现的功能,使用EARS(Easy Approach to Requirements Syntax)记法提取并文档化功能需求、非功能需求、用户故事。
---

# rev-requirements

## 目的

从现有代码库逆向生成需求定义书。分析已实现的功能,使用EARS(Easy Approach to Requirements Syntax)记法提取并文档化功能需求、非功能需求、用户故事。

## 前提条件

- 存在待分析的代码库
- 存在 `docs/reverse/` 目录(如果不存在则创建)
- 如果可能,已执行 `/jimu:rev-tasks` 和 `/jimu:rev-design`

## 执行内容

1. **功能识别与分析**
   - 从UI组件提取界面功能
   - 从API端点识别业务功能
   - 从数据库架构推测数据需求
   - 从测试代码确认预期行为

2. **用户故事逆推**
   - 从已实现的功能推测用户意图
   - 识别WHO(用户类型)
   - 提取WHAT(想实现的事)
   - 推测WHY(获得的价值)

3. **使用EARS记法进行需求分类**
   - **常规需求(SHALL)**: 从标准功能实现中提取
   - **条件需求(WHEN/IF-THEN)**: 从条件分支逻辑中提取
   - **状态需求(WHERE)**: 从状态管理实现中提取
   - **可选需求(MAY)**: 从可配置功能中提取
   - **约束需求(MUST)**: 从验证·限制逻辑中提取

4. **非功能需求推测**
   - 性能需求: 从已实现的缓存、优化中推测
   - 安全需求: 从认证·授权实现中提取
   - 可用性需求: 从UI/UX实现中提取
   - 运维需求: 从日志、监控实现中提取

5. **Edge案例识别**
   - 从错误处理实现中提取异常系统需求
   - 从验证实现中提取边界值需求
   - 从测试用例中提取预期的错误案例

6. **生成验收标准**
   - 从已实现的测试逆推验收标准
   - 将未实现的测试用例作为推荐事项提示

7. **文件创建**
   - 保存为 `docs/reverse/{项目名}-requirements.md`

## 输出格式示例

```markdown
# {项目名} 需求定义书(逆向生成)

## 分析概要

**分析日期**: {执行日期}
**目标代码库**: {路径}
**提取需求数**: {功能需求数}个功能需求、{非功能需求数}个非功能需求
**可信度**: {分析可信度} % (基于实现覆盖率)

## 系统概述

### 推测的系统目的
{从已实现的功能推测的系统目的}

### 目标用户
{从UI组件和功能推测的用户类型}

## 用户故事

### 故事1: 用户认证
- **作为** 未注册·现有用户
- **我想要** 安全地登录到系统
- **这样可以** 访问个人信息和服务

**实现依据**:
- `LoginForm.tsx` - 登录表单实现
- `POST /auth/login` - 认证API实现
- `useAuth` 钩子 - 认证状态管理

### 故事2: {其他故事}

{从已实现的功能推测的其他用户故事}

## 功能需求(EARS记法)

### 常规需求

#### REQ-001: 用户认证
系统必须提供使用有效电子邮件地址和密码的用户登录功能。

**实现依据**:
- `auth.service.ts:login()` 方法
- `POST /auth/login` 端点
- JWT令牌发行实现

#### REQ-002: 会话管理
系统必须管理登录后的用户会话。

**实现依据**:
- 通过JWT令牌进行会话管理
- 使用 `useAuth` 钩子进行状态管理
- 在本地存储中持久化令牌

### 条件需求

#### REQ-101: 认证失败时的处理
当提供无效认证信息时,系统必须显示适当的错误消息。

**实现依据**:
- `auth.controller.ts` 的错误处理
- `LoginForm.tsx` 的错误显示实现

#### REQ-102: 令牌过期时的处理
当JWT令牌过期时,系统必须将用户重定向到重新登录页面。

**实现依据**:
- `axios.interceptors` 中的401错误处理
- 自动登出功能实现

### 状态需求

#### REQ-201: 登录状态下的显示
当用户处于登录状态时,系统必须显示已认证用户的UI。

**实现依据**:
- 使用 `useAuth` 钩子确认认证状态
- 根据认证状态进行条件渲染

### 可选需求

#### REQ-301: 登录状态记忆
系统可以记住用户的登录状态。

**实现依据**:
- 在本地存储中保存令牌
- 自动登录功能实现

### 约束需求

#### REQ-401: 密码要求
系统必须对密码设置最少8个字符的约束。

**实现依据**:
- 前端验证实现
- 使用 `yup` 架构定义约束

#### REQ-402: 速率限制
系统必须对登录尝试设置速率限制。

**实现依据**:
- `express-rate-limit` 中间件实现

## 非功能需求

### 性能

#### NFR-001: 登录响应时间
系统必须在2秒内完成正常的登录处理。

**实现依据**:
- 数据库索引设置
- 高效的查询实现

#### NFR-002: 并发用户数
系统必须能够处理100个用户的同时访问。

**推测依据**:
- 连接池设置
- 服务器配置

### 安全性

#### NFR-101: 认证令牌加密
系统必须适当加密JWT令牌。

**实现依据**:
- 使用 `jsonwebtoken` 库
- 使用密钥签名实现

#### NFR-102: HTTPS通信
系统必须在生产环境中强制使用HTTPS通信。

**实现依据**:
- SSL配置文件
- HTTPS重定向实现

### 可用性

#### NFR-201: 响应式设计
系统必须在移动设备上也能使用。

**实现依据**:
- CSS媒体查询实现
- 响应式UI组件

#### NFR-202: 可访问性
系统必须满足基本的可访问性要求。

**实现依据**:
- 使用ARIA属性
- 语义化HTML结构

### 运维性

#### NFR-301: 日志输出
系统必须记录重要操作的日志。

**实现依据**:
- 使用 `winston` 日志库
- 结构化日志实现

#### NFR-302: 错误追踪
系统必须能够追踪发生的错误。

**实现依据**:
- 错误处理实现
- 通过日志输出进行追踪

## Edge案例

### 错误处理

#### EDGE-001: 网络故障
网络连接不稳定时的重试处理

**实现依据**:
- `axios` 的重试设置
- 错误提示显示

#### EDGE-002: 服务器宕机
后端服务器不可用时的处理

**实现依据**:
- 后备功能
- 错误页面显示

### 边界值

#### EDGE-101: 最大字符数限制
输入字段的最大字符数限制

**实现依据**:
- 表单验证实现
- 数据库约束

#### EDGE-102: 空字符·null值处理
对空字符和null值的适当处理

**实现依据**:
- 验证实现
- 默认值设置

## 验收标准

### 已实现功能测试

- [x] 用户登录功能
  - [x] 使用有效认证信息登录成功
  - [x] 使用无效认证信息登录失败
  - [x] 适当显示错误消息
- [x] 会话管理功能
  - [x] 维持登录状态
  - [x] 登出功能
  - [x] 令牌过期处理

### 推荐附加测试

- [ ] **性能测试**
  - [ ] 登录响应时间测量
  - [ ] 并发访问负载测试
- [ ] **安全测试**
  - [ ] SQL注入防护测试
  - [ ] XSS防护测试
  - [ ] CSRF防护测试
- [ ] **可访问性测试**
  - [ ] 屏幕阅读器支持测试
  - [ ] 键盘操作测试

## 未推测的需求

### 不明确的部分

以下需求难以从实现中推测,需要与利益相关者确认:

1. **业务需求**
   - 系统使用目的的详情
   - 目标用户的详细属性
   - 收益模式和业务目标

2. **运维需求**
   - 备份·恢复需求
   - SLA(服务水平协议)
   - 监控·告警需求

3. **法律·合规需求**
   - 遵守数据保护规定
   - 行业特定的监管要求

### 推荐的下一步

1. **利益相关者访谈** - 确认推测的需求
2. **可用性测试** - 确认实际的可用性需求
3. **性能测试** - 验证非功能需求
4. **安全审计** - 详细验证安全需求

## 分析的限制

### 影响可信度的因素

- **注释不足**: 通过推测补充开发者意图
- **测试覆盖率**: {%}% - 未测试部分的需求为推测
- **文档不足**: 不存在外部规格说明书
- **遗留代码**: 旧的实现模式导致推测困难

### 推测的依据

- **强依据**: 实现 + 测试 + 明确的行为
- **中等依据**: 实现 + 部分测试
- **弱依据**: 仅实现,通过推测补充

```

## 需求提取算法

### 1. 功能需求提取流程

```
1. API端点 → 业务功能需求
2. UI组件 → 用户界面需求
3. 数据库架构 → 数据需求
4. 验证实现 → 约束需求
5. 条件分支 → 条件需求
```

### 2. 非功能需求推测流程

```
1. 配置文件 + 库 → 性能·安全需求
2. UI实现模式 → 可用性需求
3. 日志·监控实现 → 运维需求
4. 测试实现 → 质量需求
```

### 3. 用户故事逆推流程

```
1. 界面流程 → 用户旅程
2. 表单·输入项 → 用户操作
3. 数据CRUD操作 → 用户需求
4. 权限·角色实现 → 用户类型
```

## 执行命令示例

```bash
# 完整分析(提取所有需求)
claude code rev-requirements

# 仅提取特定需求类别
claude code rev-requirements --target functional
claude code rev-requirements --target non-functional
claude code rev-requirements --target user-stories

# 可信度过滤
claude code rev-requirements --confidence high
claude code rev-requirements --confidence medium

# 分析特定目录
claude code rev-requirements --path ./src

# 指定输出格式
claude code rev-requirements --format markdown,json
```

## 执行后确认

- 显示提取的需求数(功能需求·非功能需求)
- 报告分析的可信度和依据的强度
- 提示难以推测的需求或需要确认的项目
- 生成利益相关者确认的问题列表
- 建议下一步推荐行动(添加测试、完善文档等)
