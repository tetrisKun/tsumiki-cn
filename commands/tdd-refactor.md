---
description: 执行TDD的Refactor阶段。在通过测试的实现完成后,进行代码质量改进和重构。
allowed-tools: Read, Glob, Grep, Task, Write, Edit, TodoWrite
argument-hint: [需求名称] [TASK-ID]
---
执行TDD的Refactor阶段,改进Green阶段创建的实现代码的质量。

# context

输出目录="./docs/implements"
功能名={{feature_name}}
任务ID={{task_id}}
需求名称={{requirement_name}}
可靠性评估=[]
备忘录文件=./docs/implements/{需求名称}/{{task_id}}/{feature_name}-memo.md
需求定义文件=./docs/implements/{需求名称}/{{task_id}}/{feature_name}-requirements.md
测试用例文件=./docs/implements/{需求名称}/{{task_id}}/{feature_name}-testcases.md
Green阶段文件=./docs/implements/{需求名称}/{{task_id}}/{feature_name}-green-phase.md
Refactor阶段文件=./docs/implements/{需求名称}/{{task_id}}/{feature_name}-refactor-phase.md

# step

- 如果没有 $ARGUMENTS,则说"请在参数中指定需求名称和TASK-ID(例: 用户认证功能 TASK-0001)"后结束
- 向用户声明 $ARGUMENTS 的内容和 context 的内容
- 执行 step2

## step2: 上下文准备

执行开发上下文的准备:

1. **确认现有的实现文档**
   - 确认 `./docs/implements/{需求名称}/{{task_id}}/` 目录内的所有MD文件
   - 优先读取以下文件:
     - `note.md` - 任务笔记(技术栈、开发规则、相关实现)
     - `{feature_name}-requirements.md` - 需求定义
     - `{feature_name}-testcases.md` - 测试用例定义
     - `{feature_name}-green-phase.md` - Green阶段的实现记录
     - `{feature_name}-refactor-phase.md` - 现有的Refactor阶段记录
     - `{feature_name}-memo.md` - 开发历史备忘录
     - 其他相关MD文件
   - 从这些文件了解现有的实现状况、设计判断、注意事项

2. **读取附加规则**
   - 如果存在 `AGENTS.md` 文件则读取
   - 如果存在 `./docs/rule` 目录则读取
   - 如果存在 `./docs/rule/tdd` 目录则读取
   - 如果存在 `./docs/rule/tdd/refactor` 目录则读取
   - 读取各目录内的所有文件,作为附加规则应用

3. **使用 @agent-symbol-searcher 搜索重构相关信息,并读取找到的文件**
   - 搜索现有的代码风格和最佳实践,使用Read工具读取风格指南
   - 识别项目整体的架构模式,使用Read工具读取设计文档
   - 确认可重用的工具函数或组件,使用Read工具读取相关文件

4. **直接读取相关的外部文件**
   - 根据需要读取相关的设计文档或任务文件
   - 项目整体的设计文档、架构文档等

读取完成后,执行 step3

## step3: 测试执行和代码质量确认

- **确认当前所有测试通过**
  - 【质量保证】: 重构前的动作确认
  - 【安全性确保】: 防止因变更导致功能破损
  - 【执行方法】: 使用Task工具执行测试,详细分析结果

- **代码・测试排除检查**
  - 【.gitignore确认】: 检查本应确认的代码文件是否被排除
  - 【测试排除确认】: 检查测试是否被 `describe.skip`、`it.skip`、`test.skip` 等禁用
  - 【jest设置确认】: 检查 `jest.config.js` 或 `package.json` 的 `testPathIgnorePatterns` 等是否排除了测试文件
  - 【执行对象确认】: 检查应该执行的测试和代码是否适当包含在对象中

- **开发时生成文件的清理**
  - 【不必要文件检测】: 检测・删除开发中创建的临时文件
  - 【对象文件模式】: 确认符合以下模式的文件
    - `debug-*.js`、`debug-*.ts`: 调试用脚本
    - `test-*.js`、`test-*.ts`、`temp-*.js`: 临时测试文件
    - `*.tmp`、`*.temp`、`*.bak`、`*.orig`: 临时・备份文件
    - `*~`、`.DS_Store`: 编辑器・系统生成文件
    - `test-output-*`、`*.test-output`: 测试输出文件
  - 【安全确认】: 删除前确认各文件的内容,检查是否包含重要代码
  - 【选择性删除】: 仅删除判断为不必要的文件,保留必要的文件
  - 【删除日志】: 记录删除的文件和删除理由
  - 【执行步骤】:
    1. 用 `find . -name "debug-*" -o -name "test-*" -o -name "temp-*" -o -name "*.tmp" -o -name "*.temp" -o -name "*.bak" -o -name "*.orig" -o -name "*~" -o -name ".DS_Store" | grep -v node_modules` 检测文件
    2. 使用Read工具确认各文件的内容
    3. 删除判断为不必要的文件,记录删除理由

- 执行 step4

## step4: 审查和改进计划

- **实施安全审查**
  - 【脆弱性检查】: 识别整个代码的安全漏洞
  - 【输入验证确认】: 确认对非法输入值的防御功能
  - 【应用安全指南】: 应用行业标准的安全最佳实践
  - 文档化审查结果

- **实施性能审查**
  - 【计算量分析】: 评估算法的时间复杂度・空间复杂度
  - 【瓶颈识别】: 识别处理速度和内存使用量的问题部位
  - 【优化策略】: 制定具体的性能改进措施
  - 文档化审查结果

- **创建改进计划**
  - 参考 <refactoring_guidelines> 制定改进计划
  - 为各改进项目赋予可靠性级别(🔵🟡🔴)
  - 决定改进的优先级

- 执行 step5

## step5: 执行重构

- **逐一应用小改进**
  - 【阶段性改进】: 限定影响范围的安全变更
  - 【可追踪性】: 确保变更内容的可追踪性
  - 按照 <refactoring_guidelines> 的各观点实施改进
  - 按照 <comment_template> 强化中文注释

- **各改进后执行测试**
  - 【持续验证】: 每次改进后确认动作
  - 【早期发现】: 问题的早期发现和修正
  - 【执行方法】: 使用Task工具执行测试,确认改进的影响

- **测试失败时立即回退**
  - 【快速恢复】: 问题发生时的快速应对
  - 【维持稳定性】: 保持系统的稳定状态

- 根据质量判定标准评估重构内容:
  - 测试成功状况
  - 安全质量
  - 性能质量
  - 代码质量的提升度
  - 文件大小(500行限制)
  - 中文注释的质量

- 向用户显示质量判定结果
- 执行 step6

## step6: 文档更新

- **创建/更新Refactor-phase文件**:
  - 将重构内容和设计改进保存到 {{Refactor阶段文件}}
  - 如果存在现有文件则追加
  - 记录以下内容:
    - 改进的代码全文
    - 改进要点的说明
    - 安全审查结果
    - 性能审查结果
    - 测试执行结果
    - 注释改进内容

- **备忘录文件的最终更新**:
  - 更新 {{备忘录文件}} 的Refactor阶段部分和概要
  - 如果没有现有备忘录文件则新建(遵循TDD备忘录文件格式)
  - 记录以下内容:
    - 重构日期时间
    - 改进内容
    - 安全审查结果
    - 性能审查结果
    - 最终代码
    - 质量评价
  - 将概要部分的当前阶段更新为"完成"

- 执行 step7

## step7: TODO更新和完成判定

- 使用 TodoWrite 工具更新 TODO 状态
  - 将当前TODO"Refactor阶段(质量改进)"标记为"completed"
  - 在TODO内容中反映重构阶段的完成
  - 在TODO内容中记录质量判定结果
  - 将下一阶段"完整性验证"添加到TODO
  - 如果有需要改进的部分,作为新TODO添加

- **质量判定**: 根据以下标准判定重构成果的质量
  - 测试结果: 所有测试继续成功
  - 安全: 未发现重大脆弱性
  - 性能: 未发现重大性能问题
  - 重构质量: 达成目标
  - 代码质量: 提升到适当水平

- **显示下一步**: 不管判定结果如何,显示推荐的下一个命令
  - "推荐的下一步: 使用 `/tsumiki:tdd-verify-complete` 执行完整性验证。"

# rules

## 重构的原则

- **不进行功能性变更**(禁止添加新功能)
- **测试不通过时立即修正**
- **不一次进行大的变更**
- **也提升中文注释的质量**
- **质量确认的测试执行时使用Task工具**

## 禁止事项(NEVER)

- 在实现代码内描述模拟・桩
- 在实现代码内使用代替DB的内存存储

## 文件大小管理

- **500行限制**: 分割・优化使文件大小在500行以下
- **按功能分割大文件**
- **设置适当的模块边界**

## 可靠性级别指示

重构时,请用以下信号注释各改进内容与原始资料的对照情况:

- 🔵 **绿灯**: 参考原始资料几乎没有推测的情况
- 🟡 **黄灯**: 从原始资料进行合理推测的情况
- 🔴 **红灯**: 原始资料中没有的推测情况

## 质量判定标准

```
✅ 高质量:
- 测试结果: Task工具执行全部继续成功
- 安全: 无重大脆弱性
- 性能: 无重大性能问题
- 重构质量: 目标达成
- 代码质量: 适当水平
- 文档: 完成

⚠️ 需改进:
- 部分测试失败(Task工具检测)
- 发现安全脆弱性
- 发现性能问题
- 重构目标未达成
- 质量改进不充分
- 文档不完整
```

## 文件路径记载规则

- **使用以项目根目录为基准的相对路径**
- 不记载全路径(绝对路径)
- 例:
  - ❌ `/Users/username/projects/myapp/src/utils/helper.ts`
  - ✅ `src/utils/helper.ts`

# info

<refactoring_guidelines>
# 重构的观点

## 1. 可读性的提升

- 改进变量名・函数名
- 充实中文注释
- 使代码结构易于理解

## 2. 去除重复代码(DRY原则)

- 共通化相同的处理
- 提取常量
- 创建辅助函数

## 3. 设计的改进

- 应用单一职责原则
- 整理依赖关系
- 考虑模块化

## 4. 文件大小的优化

- 分割・优化使文件大小在500行以下
- 按功能分割大文件
- 设置适当的模块边界

## 5. 确保代码质量

- 消除lint错误
- 消除typecheck错误
- 统一格式
- 通过静态分析工具检查

## 6. 安全审查

- 检测和修正导致脆弱性的实现
- 强化输入值验证
- 确认SQL注入对策
- 确认XSS(跨站脚本攻击)对策
- 确认CSRF(跨站请求伪造)对策
- 避免数据泄漏风险
- 适当实现认证・授权

## 7. 性能审查

- 算法的计算量分析
- 优化内存使用量
- 删除不必要的处理
- 考虑缓存策略
- 优化数据库查询
- 提高循环处理效率
- 适当实现异步处理

## 8. 充实错误处理

- 验证输入值
- 适当的错误消息
- 改进异常处理
</refactoring_guidelines>

<comment_template>
# 重构时的中文注释强化要求

重构时请改进现有的中文注释,并添加新的注释:

## 改进的函数・方法的注释

```javascript
/**
 * 【功能概要】: [重构后功能的详细说明]
 * 【改进内容】: [说明进行了什么样的改进]
 * 【设计方针】: [为什么采用这个设计的理由]
 * 【性能】: [性能方面的考虑事项]
 * 【可维护性】: [为了易于维护的功夫]
 * 🔵🟡🔴 可靠性级别: [此改进在多大程度上基于原始资料]
 * @param {type} paramName - [参数的详细说明和约束]
 * @returns {type} - [返回值的详细说明和保证事项]
 */
function improvedFunction(paramName) {
  // 【实现详细】: [改进的实现内容和理由]
}
```

## 辅助函数・工具的注释

```javascript
/**
 * 【辅助函数】: [此函数的作用和创建理由]
 * 【可重用性】: [什么样的场面可以重用]
 * 【单一职责】: [此函数担当的职责范围]
 */
function helperFunction(input) {
  // 【处理效率化】: [提高处理效率的功夫] 🔵🟡🔴
  // 【可读性提升】: [提高代码可读性的机制] 🔵🟡🔴
}
```

## 常量・设定值的注释

```javascript
// 【设定常量】: [此常量的作用和设定理由] 🔵🟡🔴
// 【可调整性】: [将来需要调整的可能性和方法] 🔵🟡🔴
const IMPROVED_CONSTANT = 100; // 【已优化】: 基于性能测试优化 🔵🟡🔴

// 【设定对象】: [汇总设定的理由和管理方针]
const CONFIG = {
  // 【各设定项目】: [各设定值的意义和影响范围]
  maxRetries: 3, // 【重试次数】: 基于实际运用经验的适当次数
  timeout: 5000, // 【超时】: 考虑可用性的时间设定
};
```

## 错误处理改进的注释

```javascript
try {
  // 【安全处理执行】: [可能发生异常和对策]
  const result = riskyOperation();
} catch (error) {
  // 【详细错误处理】: [根据错误种类的适当处理]
  // 【可用性】: [对用户来说易于理解的错误应对]
  if (error.code === 'SPECIFIC_ERROR') {
    // 【特定错误应对】: [此错误特化处理的理由]
    return handleSpecificError(error);
  }
  // 【一般错误应对】: [对意外错误的安全应对]
  return handleGenericError(error);
}
```
</comment_template>

<refactoring_example>
# 重构示例

```javascript
// Before: 硬编码
function add(a, b) {
  return 5; // 暂且能动的实现
}

// After: 适当的实现(附带改进的中文注释)
/**
 * 【功能概要】: 加算2个数值,返回结果
 * 【改进内容】: 删除硬编码,实现实际的加算处理
 * 【设计方针】: 重视输入值验证和类型安全性的设计
 * 【错误处理】: 实现对非法输入的适当异常处理
 */
function add(firstNumber, secondNumber) {
  // 【输入值验证】: 早期检测数值以外的输入,防止错误
  // 【类型安全性】: 与TypeScript的类型检查一起实施运行时验证
  if (typeof firstNumber !== 'number' || typeof secondNumber !== 'number') {
    // 【可用性】: 提供对开发者来说易于理解的错误消息
    throw new Error('参数必须是数值');
  }

  // 【主处理】: 简单确实的加算处理
  // 【性能】: 避免不必要处理的高效实现
  return firstNumber + secondNumber;
}
```
</refactoring_example>
